# 约瑟夫环问题解析

## 历史

约瑟夫问题（有时也称为约瑟夫斯置换），是一个出现在计算机科学和数学中的问题。在计算机编程的算法中，类似问题又称为约瑟夫环。

人们站在一个等待被处决的圈子里。 计数从圆圈中的指定点开始，并沿指定方向围绕圆圈进行。 在跳过指定数量的人之后，处刑下一个人。 对剩下的人重复该过程，从下一个人开始，朝同一方向跳过相同数量的人，直到只剩下一个人，并被释放。

问题即，给定人数、起点、方向和要跳过的数字，选择初始圆圈中的位置以避免被处决。

这个问题是以弗拉维奥·约瑟夫命名的，他是1世纪的一名犹太历史学家。他在自己的日记中写道，他和他的40个战友被罗马军队包围在洞中。他们讨论是自杀还是被俘，最终决定自杀，并以抽签的方式决定谁杀掉谁。约瑟夫斯和另外一个人是最后两个留下的人。约瑟夫斯说服了那个人，他们将向罗马军队投降，不再自杀。约瑟夫斯把他的存活归因于运气或天意，他不知道是哪一个。

## leetcode 原题

[原题链接](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof)

0, 1, ···, n-1 这 n 个数字排成一个圆圈，从数字 0 开始，每次从这个圆圈里删除第 m 个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4 这 5 个数字组成一个圆圈，从数字 0 开始每次删除第 3 个数字，则删除的前 4 个数字依次是 2、0、4、1，因此最后剩下的数字是 3。

## 递归解题思路

如果记上述问题为函数 f(n, m)，这时第一个被删除的数字为 (m - 1) % n。当第一个数字被删除后，第二轮删除将从 m % n 处开始，而第二轮删除则可以记为函数 f(n - 1, m)。将 f(n, m) 的问题转化为了 f(n - 1, m) 的问题，所以可以使用递归求解，只需要知道上一轮的 f(n, m) 和下一轮的 f(n - 1, m) 的关系即可。

我们这里将第一轮的数字画成图观察：

```
// 第一轮没有删除数字之前如下，一共 0 ~ (n - 1) 个数字

0
1
...
(m - 1) % n
m % n
...
n - 1

```

// 而第一轮删除后的数字变成了如下形式：

```
// (m - 1) % n 被删除

0
1
...
(m - 2) % n
m % n
...
n - 1

```

(m - 1) % n 被删除后，排在它前面的所有数字将被移动到尾部，因为下一轮删除将从 m % n 为起点开始：

```
// m % n 是新的起点

m % n
(m + 1) % n
...
n - 1
0
...
(m - 2) % n

```

于是新的起点是旧一轮的 m % n，而作为新的一轮，它是 0，于是就有如下一一对映的关系：

```
// 上一轮和下一轮数字关系

m % n ------------------- 0
(m + 1) % n ------------- 1
...                       ...
n - 1 ------------------- (n - 1) - (m % n)
0 ----------------------- n - (m % n)
...                       ...
(m - 2) % n ------------- n - 2
```

这时候记旧一轮的序号为 y，新一轮的序号为 x，则它们的关系通过上图可以推导出：

```
y = (m - 2) % n
x = n - 2

(m - 2) % n
(m - 2) % n + 0
(m - 2) % n + (n % n)
(m + n - 2) % n
((n - 2) + m) % n

// 就是如下公式：

y = (x + m) % n

// 而将 x 和 y 换成对应的 f 函数，则得到下面的递归公式：

f(n, m) = (f(n - 1, m) + m) % n (n > 1)
f(1, m) = 0 (n = 1)
```

有了这个公式 `f(n, m) = (f(n - 1, m) + m) % n`，就可以写出递归调用的代码了：


```js
var lastRemaining = function(n, m) {
    if (n === 1) return n - 1;
    return (lastRemaining(n - 1, m) + m) % n;
};
```
