# 垃圾回收

## 调用栈

执行栈，也就是在其它编程语言中所说的“调用栈”，是用来管理函数调用关系的一种数据结构，它被用来存储代码运行时创建的所有执行上下文。

* 当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前调用栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。
* 引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。
* 当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。

```js

var a = 2
function add(b,c) {
  return b + c
}
function addAll(b,c) {
  var d = 10
  result = add(b,c)
  return  a + result + d
}
addAll(3,6)
```

1. 创建全局上下文，并将其压入栈底。全局上下文的变量环境对象包含 变量 a = undefined；函数 add；函数 addAll。
2. 开始执行全局代码。变量 a 赋值变为 2。
3. addAll 函数被调用。编译该函数创建一个执行上下文，将该函数的执行上下文压入栈。d = undefined；result = undefined。
4. 执行 addAll 函数代码。d 赋值为 10。
5. add 函数被调用。编译该函数创建一个执行上下文，将该函数的执行上下文压入栈。
6. 执行 add 函数代码。返回 9，add 函数执行上下文从调用栈中弹出。addAll 中 result 被赋值为 9。
7. addAll 返回 21，addAll 函数执行上下文从调用栈中弹出。这时候调用栈中只剩下全局执行上下文了。

## 栈空间和堆空间

* js 中的变量存储在 栈空间 和 堆空间中。函数的执行上下文会存储在栈空间中，执行上下文中的原始类型的值（布尔，数字，字符串）直接保存在栈空间中，而引用类型的值（对象）保存在堆空间中，栈空间中只保存引用类型在堆中的地址。栈来维护程序执行期间上下文的状态，如果所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。

* 栈内存的回收：调用栈在执行每一个函数的时候，有一个记录当前执行状态的指针（ESP），当一个函数执行结束，ESP 向下移动，指向另一个函数的执行上下文，上面函数的执行上下文虽然保存在栈内存中，但是已经是无效内存了。如果再有新的函数被调用，这块内存会直接被覆盖掉。

* 堆内存的回收：
    * 当栈中的 ESP 指针移动的时候，调用结束的执行上下文就无效了，但是它引用的引用类型数据依然占用堆中的空间。
    * 代际假说：
        1. 大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；
        2. 不死的对象，会活得更久。
    * V8 中会把堆分为 新生代 和 老生代 两个区域
        1. 新生代中存放的是生存时间短的对象。副垃圾回收器，主要负责新生代的垃圾回收。
        2. 老生代中存放的生存时间久的对象。主垃圾回收器，主要负责老生代的垃圾回收。
    * 不论什么类型的垃圾回收器，它们都有一套共同的执行流程：
        1. 标记空间中活动对象和非活动对象。
        2. 回收非活动对象所占据的内存。
        3. 内存整理
    * 副垃圾回收器：
        1. 新生代中用Scavenge 算法来处理。新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域
        2. 新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。
        3. 在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。
        4. 完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。
        5. 因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。
    * 主垃圾回收器：
        1. 标记 - 清除（Mark-Sweep）：遍历调用栈，标记活动对象和垃圾数据。然后将垃圾数据清除掉。
        2. 标记 - 整理（Mark-Compact）：遍历调用栈，标记活动对象和垃圾数据，存活的对象都向一端移动，然后直接清理掉端边界以外的内存。


## 全停顿

JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）。

为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法。

使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。