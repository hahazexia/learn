# 事件循环

## 进程和线程

* `一个进程就是一个程序的运行实例`。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。

* `线程`是依附于进程的，而进程中使用多线程并行处理能提升运算效率。

* 进程和线程的关系
    * 进程中的任意一线程执行出错，都会导致整个进程的崩溃
    * 线程之间共享进程中的数据
    * 当一个进程关闭之后，操作系统会回收进程所占用的内存
    * 进程之间的内容相互隔离

* 而浏览器运行的时候是多进程的，包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。

## 渲染进程

渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下

每个渲染进程都有一个主线程，并且主线程非常繁忙，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件。要让这么多不同类型的任务在主线程中有条不紊地执行，这就需要一个系统来统筹调度这些任务，这个统筹调度系统就是我们今天要讲的消息队列和事件循环系统。

## 事件循环和消息队列

1. 所有任务都在主线程上执行。
2. 主线程之外，还存在一个消息队列。只要其他任务有了运行结果，就放在消息队列中排队等待执行。例如 输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等等。
3. 一旦主线程中的所有任务执行完毕，系统就会读取消息队列，看看里面有哪些在排队的任务。那些任务结束等待状态，进入主线程执行栈，开始执行。

主线程不断重复上面的第三步。这就是事件循环和消息队列。

## 任务和微任务

* 任务（Tasks）就是一段被执行的任意 JavaScript 代码。这些都在 任务队列（task queue）上被调度。例如，一段被直接执行的程序，事件出发后的回调函数，或 setInterval 和 setTimeout 设置的定时器回调。

* 每当一个任务存在，事件循环都会检查该任务是否正把控制权交给其他 JavaScript 代码。如果不需要，事件循环就会运行微任务队列中的所有微任务。如果一个微任务通过调用 queueMicrotask(), 向队列中加入了更多的微任务，则那些新加入的微任务 会早于下一个任务运行 。这是因为事件循环会持续调用微任务直至队列中没有留存的，即使是在有更多微任务持续被加入的情况下。

* 微任务（Microtasks）包括 queueMicrotask 添加的回调函数，promise，MutationObserver 等。

* 消息队列机制并不是太灵活，为了适应效率和实时性，才引入了微任务。