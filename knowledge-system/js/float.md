# 浮点数精度

下面的结果是什么？为什么？
```js
0.1 + 0.2 === 0.3
```

答案

```js
0.1 + 0.2 === 0.3 //false
```

造成这样的结果的原因是因为js内部所有的数字都是以64位浮点数形式储存，在做运算的时候，是以这种64位浮点形式来运算，也就是二进制数。
十进制的小数转换成二进制时，规则是乘二取整，这样有可能无限循环下去，而除去指数位，双精度浮点数的小数位最多能保留53位，所以这样必然会损失掉一部分精度。计算完成后再转换成十进制，损失的精度造成了 0.1 + 0.2 不等于 0.3。

0.1 转换成二进制为 0.0001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 101<br/>
0.2 转换成二进制为 0.0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 001<br/>
它们相加结果为 0.0100110011001100110011001100110011001100110011001101<br/>
转换成十进制为 0.30000000000000004<br/>

0.30000000000000004 不等于 0.3<br/>

为什么十进制小数转换成二进制时是乘二取整？<br/>

以二进制数1111.1111为例

```js
1111.1111
//小数点左边第一位的1代表有1个1，2^0
//小数点左边第二位的1代表有1个2, 2^1
//小数点左边第三位的1代表有1个4, 2^2
//小数点左边第四位的1代表有1个8, 2^3

//小数点右边第一位的1代表有1个0.5（二分之一），2^-1
//小数点右边第二位的1代表有1个0.25（四分之一），2^-2
//小数点右边第三位的1代表有1个0.125（八分之一），2^-3
//小数点右边第四位的1代表有1个0.0625（十六分之一），2^-4

```

上面的例子可以看出想要计算出十进制小数对应的二进制，就只需知道有多少个二分之一，四分之一，八分之一，十六分之一。所以就要用十进制数字的小数部分去除以二分之一，四分之一，八分之一，十六分之一，也就是乘以`2`，乘以`2*2`，乘以`2*2*2`，乘以`2*2*2*2`，然后取每一次乘2的整数部分作为对应的二进制位。

```js
//计算十进制0.3转换成二进制
0.3 * 2 = 0.6 取整数位0
0.6 * 2 = 1.2 取整数位1
0.2 * 2 = 0.4 取整数位0
0.4 * 2 = 0.8 取整数位0
0.8 * 2 = 1.6 取整数位1
0.6 * 2 = 1.2 取整数位1
......

二进制数：0.010011...... // 无限循环下去

```