# jsx 语法

## ES6 的 Class

在ES6之前，我们通过function来定义类，但是这种模式一直被很多从其他编程语言（比如Java、C++、OC等等）转到JavaScript的人所不适应。原因是，大多数面向对象的语言，都是使用class关键字来定义类的。而JavaScript也从ES6开始引入了class关键字，用于定义一个类。ES6之前定义一个Person类：

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.running = function() {
  console.log(this.name + this.age + "running");
}

var p = new Person("why", 18);
p.running();
```

转换成ES6中的类如何定义呢？类中有一个constructor构造方法，当我们通过new关键字调用时，就会默认执行这个构造方法。构造方法中可以给当前对象添加属性，类中也可以定义其他方法，这些方法会被放到Person类的prototype上。

```js
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  running() {
    console.log(this.name + this.age + "running");
  }
}

const p = new Person("why", 18);
p.running();
```

### 类的继承

继承是面向对象的一大特性，可以减少我们重复代码的编写，方便公共内容的抽取（也是很多面向对象语言中，多态的前提）。ES6中增加了extends关键字来作为类的继承。我们先写两个类没有继承的情况下，它们存在的重复代码：Person类和Student类

```js
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  running() {
    console.log(this.name, this.age, "running");
  }
}

class Student {
  constructor(name, age, sno, score) {
    this.name = name;
    this.age = age;
    this.sno = sno;
    this.score = score;
  }

  running() {
    console.log(this.name, this.age, "running");
  }

  studying() {
    console.log(this.name, this.age, this.sno, this.score, "studing");
  }
}
```

我们可以使用继承来简化代码：注意：在constructor中，子类必须通过super来调用父类的构造方法，对父类进行初始化，否则会报错。

```js
class Student1 extends Person {
  constructor(name, age, sno, score) {
    super(name, age);
    this.sno = sno;
    this.score = score;
  }

  studying() {
    console.log(this.name, this.age, this.sno, this.score, "studing");
  }
}

const stu1 = new Student1("why", 18, 110, 100);
stu1.studying();
```

## 案例：电影列表

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div id="app"></div>
    <!-- 引入依赖 -->
    <script src="./react/react.development.js"></script>
    <script src="./react/react-dom.development.js"></script>
    <script src="./react/babel.min.js"></script>

    <!-- 编写 react 代码 -->
    <script type="text/babel">
        class App extends React.Component {
            constructor () {
                super();

                this.state = {
                    message: 'Hello World',
                    movies: ['大话西游', '盗梦空间', '星际穿越', '流浪地球']
                }
            }

            render () {
                const liArr = [];
                for (let i of this.state.movies) {
                    liArr.push(<li>{i}</li>)
                }

                return (
                    <div>
                        <h2>电影列表</h2>
                        <ul>
                            {liArr}
                        </ul>

                        
                        <h2>电影列表2</h2>
                        <ul>
                            {this.state.movies.map(i => (<li>{i}</li>))}
                        </ul>
                    </div>
                )
            }
        }

        ReactDOM.render(<App />, document.getElementById('app'))
    </script>
</body>
</html>
```

## 案例：计数器

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div id="app"></div>
    <!-- 引入依赖 -->
    <script src="./react/react.development.js"></script>
    <script src="./react/react-dom.development.js"></script>
    <script src="./react/babel.min.js"></script>

    <!-- 编写 react 代码 -->
    <script type="text/babel">
        class App extends React.Component {
            constructor () {
                super();

                this.state = {
                    count: 0
                }
            }

            increase () {
                console.log('+1')
                this.setState({
                    count: this.state.count + 1
                })
            }

            decrease () {
                console.log('-1')
                this.setState({
                    count: this.state.count - 1
                })
            }

            render () {

                return (
                    <div>
                        <h2>当前计数：{this.state.count}</h2>
                        <button onClick={this.increase.bind(this)}>+1</button>
                        <button onClick={this.decrease.bind(this)}>-1</button>
                    </div>
                )
            }
        }

        ReactDOM.render(<App />, document.getElementById('app'))
    </script>
</body>
</html>
```

## jsx

JSX是什么？

* JSX是一种JavaScript的语法扩展（eXtension），也在很多地方称之为JavaScript XML，因为看起就是一段XML语法；
* 它用于描述我们的UI界面，并且其完全可以和JavaScript融合在一起使用；
* 它不同于Vue中的模块语法，你不需要专门学习模块语法中的一些指令（比如v-for、v-if、v-else、v-bind）；

为什么React选择了JSX？

* React认为渲染逻辑本质上与其他UI逻辑存在内在耦合 比如UI需要绑定事件（button、a原生等等）；比如UI中需要展示数据状态，在某些状态发生改变时，又需要改变UI；他们之间是密不可分，所以React没有将标记分离到不同的文件中，而是将它们组合到了一起，这个地方就是组件（Component）；在这里，我们只需要知道，JSX其实是嵌入到JavaScript中的一种结构语法；

JSX的书写规范：

* JSX的顶层只能有一个根元素，所以我们很多时候会在外层包裹一个div原生（或者使用后面我们学习的Fragment）；
* 为了方便阅读，我们通常在jsx的外层包裹一个小括号()，这样可以方便阅读，并且jsx可以进行换行书写；
* JSX中的标签可以是单标签，也可以是双标签；
* 注意：如果是单标签，必须以/>结尾；

### JSX嵌入表达式

如果我们jsx中的内容是动态的，我们可以通过表达式来获取：大括号内可以是变量、字符串、数组、函数调用等任意js表达式；

```js
<div>{this.state.data}</div>
```

### jsx中的注释

jsx是嵌入到JavaScript中的一种语法，所以在编写注释时，需要通过JSX的语法来编写：

```js
{/* 这是一段注释 */}
```

### JSX嵌入变量

* 情况一：当变量是Number、String、Array类型时，可以直接显示
* 情况二：当变量是null、undefined、Boolean类型时，内容为空；如果希望可以显示null、undefined、Boolean，那么需要转成字符串；转换的方式有很多，比如toString方法、和空字符串拼接，String(变量)等方式；
* 情况三：对象类型不能作为子元素（not valid as a React child），如果放到花括号中放入 jsx 中直接会报错。
* 补充：为什么null、undefined、Boolean在JSX中要显示为空内容呢？原因是在开发中，我们会进行很多的判断；在判断结果为false时，不显示一个内容；在判断结果为true时，显示一个内容；

### jsx 嵌入表达式

* 运算表达式
* 三元运算符
* 执行一个函数

### jsx绑定属性

* 比如元素都会有title属性
* 比如img元素会有src属性
* 比如a元素会有href属性
* 比如元素可能需要绑定class
* 比如原生使用内联样式style